package org.geotools.data.altibase;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.geotools.jdbc.AutoGeneratedPrimaryKeyColumn;
import org.geotools.jdbc.JDBCDataStore;
import org.geotools.jdbc.NonIncrementingPrimaryKeyColumn;
import org.geotools.jdbc.PrimaryKey;
import org.geotools.jdbc.PrimaryKeyColumn;
import org.geotools.jdbc.PrimaryKeyFinder;
import org.geotools.jdbc.SequencedPrimaryKeyColumn;
import org.geotools.util.logging.Logging;

public class AltibasePrimaryKeyFinder extends PrimaryKeyFinder {
    protected static final Logger LOGGER = Logging.getLogger(AltibasePrimaryKeyFinder.class);

    @Override
    public PrimaryKey getPrimaryKey(JDBCDataStore store, String databaseSchema, String tableName,
            Connection cx) throws SQLException {
        DatabaseMetaData metaData = cx.getMetaData();
        Statement st = null;
        ResultSet rs = null;
        try {
            st = cx.createStatement();

            String sql = "select '' as TABLE_CAT,E.user_name as TABLE_SCHEM,D.table_name as TABLE_NAME,"
                    + " decode(a.is_unique,'T',0,'F',1,1) as NON_UNIQUE,'' as INDEX_QUALIFIER, "
                    + "a.index_name as INDEX_NAME,a.index_type as TYPE,b.index_col_order+1 as ORDINAL_POSITION,"
                    + "C.column_name as COLUMN_NAME, B.SORT_ORDER as ASC_OR_DESC,0 as CARDINALITY,"
                    + "0 as PAGES,'' as FILTER_CONDITION "
                    + "FROM system_.sys_indices_ A,system_.sys_index_columns_ B,system_.sys_columns_ C,"
                    + "system_.sys_tables_ D,system_.sys_users_ E WHERE a.table_id=b.table_id  "
                    + "and c.column_id = b.column_id and b.index_id  = a.index_id and a.table_id  = d.table_id "
                    + "and d.user_id   = e.user_id  and D.table_name='"
                    + tableName
                    //****** 추가..스키마 구분 (edit by woong 12/07/04) *******
                    //다른 스키마에 같은 테이블명칭이 있으면 여러개의 키값을 찾는다.
                    + "' and E.user_name='" + databaseSchema.toUpperCase()
                    //*********************************************
                    + "' and a.is_unique = 'T' order by 6,8";

            rs = st.executeQuery(sql);

            return createPrimaryKey(store, rs, metaData, databaseSchema, tableName, cx);
        } finally {
            store.closeSafe(rs);
            store.closeSafe(st);
        }
    }

    PrimaryKey createPrimaryKey(JDBCDataStore store, ResultSet index, DatabaseMetaData metaData,
            String databaseSchema, String tableName, Connection cx) throws SQLException {
        ArrayList<PrimaryKeyColumn> cols = new ArrayList<PrimaryKeyColumn>();

        while (index.next()) {
            String columnName = index.getString("COLUMN_NAME");
            // work around. For some reason the first record returned is always 'empty'
            // this was tested on Oracle and Postgres databases
            if (columnName == null) {
                continue;
            }

            // look up the type ( should only be one row )
            ResultSet columns = metaData.getColumns(null, databaseSchema, tableName, columnName);
            columns.next();

            Class<?> columnType = store.getSQLDialect().getMapping(columns, cx);
            if (columnType == null) {
                int binding = columns.getInt("DATA_TYPE");
                columnType = store.getMapping(binding);
                if (columnType == null) {
                    LOGGER.warning("No class for sql type " + binding);
                    columnType = Object.class;
                }
            }

            // determine which type of primary key we have
            PrimaryKeyColumn col = null;

            // 1. Auto Incrementing?
            Statement st = cx.createStatement();
            try {
                // not actually going to get data
                st.setFetchSize(1);

                StringBuffer sql = new StringBuffer();
                sql.append("SELECT ");
                store.getSQLDialect().encodeColumnName(null, columnName, sql);
                sql.append(" FROM ");
                store.getSQLDialect().encodeTableName(databaseSchema, sql);
                sql.append(".");
                store.getSQLDialect().encodeTableName(tableName, sql);

                sql.append(" WHERE 0=1");

                LOGGER.log(Level.FINE, "Grabbing table pk metadata: {0}", sql);

                ResultSet rs = st.executeQuery(sql.toString());

                try {
                    if (rs.getMetaData().isAutoIncrement(1)) {
                        col = new AutoGeneratedPrimaryKeyColumn(columnName, columnType);
                    }
                } finally {
                    store.closeSafe(rs);
                }
            } finally {
                store.closeSafe(st);
            }

            // 2. Has a sequence?
            if (col == null) {
                try {
                    String sequenceName = store.getSQLDialect().getSequenceForColumn(
                            databaseSchema, tableName, columnName, cx);
                    if (sequenceName != null) {
                        col = new SequencedPrimaryKeyColumn(columnName, columnType, sequenceName);
                    }
                } catch (Exception e) {
                    // log the exception , and continue on
                    LOGGER.log(Level.WARNING, "Error occured determining sequence for "
                            + columnName + ", " + tableName, e);
                }
            }

            if (col == null) {
                col = new NonIncrementingPrimaryKeyColumn(columnName, columnType);
            }

            cols.add(col);
        }

        if (!cols.isEmpty()) {
            return new PrimaryKey(tableName, cols);
        }

        return null;
    }

}
